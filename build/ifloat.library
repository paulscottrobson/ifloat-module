; *******************************************************************************************
; *******************************************************************************************
;
;		Name : 		float.asm
;		Purpose :	Main program, also used to create module library
;		Date :		20th March 2025
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
; *******************************************************************************************
;
;		Name : 		data.inc
;		Purpose :	Data files
;		Date :		20th March 2025
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

floatCodeResume = *

; *******************************************************************************************
;
;	                                  Zero Page Usage
;
; *******************************************************************************************

        * = zeroPageSpace

floatA:

floatAFlags:
		.fill 	1
floatAExponent:
		.fill 	1
floatAMantissa:
		.fill 	4

floatB:

floatBFlags:
		.fill 	1
floatBExponent:
		.fill 	1
floatBMantissa:
		.fill 	4

floatZ0:
		.fill	3

; *******************************************************************************************
;
;								Non-Zero page data space
;
; *******************************************************************************************

		* = dataSpace

floatBufferSize:
		.fill 	1
floatBufferString:
		.fill 	33

polyCoefficientCount:
		.fill 	1
polyTempFloat:
		.fill 	6
polySign:
		.fill 	1
polyFlag:
		.fill 	1
polyExponentTemp:
		.fill 	1

floatR:
floatRFlags:
		.fill 	1
floatRExponent:
		.fill 	1
floatRMantissa:
		.fill 	4

floatBaseConvert:
		.fill 	1
floatModulusLowByte:
		.fill 	1

floatStackPointer:
        .fill   1
floatStack:
        .fill   5*6

        * = floatCodeResume

;
;	This file is automatically generated.
;
FTCMD_COUNT = 20

FTCMD_Add = 0
FTCMD_Subtract = 1
FTCMD_Multiply = 2
FTCMD_Divide = 3
FTCMD_IntDivide = 4
FTCMD_Fractional = 5
FTCMD_Integer = 6
FTCMD_FloatToString = 7
FTCMD_IntegerToDecimalString = 8
FTCMD_IntegerToString = 9
FTCMD_Scale10 = 10
FTCMD_StringToInteger = 11
FTCMD_StringToFloat = 12
FTCMD_LogarithmE = 13
FTCMD_Exponent = 14
FTCMD_SquareRoot = 15
FTCMD_Sine = 16
FTCMD_Cosine = 17
FTCMD_Tangent = 18
FTCMD_ArcTangent = 19

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      fp_macros_6502.inc
;       Purpose :   Macros (65C02)
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; -------------------------------------------------------------------------------------------
;
;                               Register to Register copy macro
;
; -------------------------------------------------------------------------------------------

FloatCopyReg .macro
        lda     \1+0
        sta     \2+0
        lda     \1+1
        sta     \2+1
        lda     \1+2
        sta     \2+2
        lda     \1+3
        sta     \2+3
        lda     \1+4
        sta     \2+4
        lda     \1+5
        sta     \2+5
        .endm

; -------------------------------------------------------------------------------------------
;
;                                       Clear A to zero
;
; -------------------------------------------------------------------------------------------
FloatClear32A .macro
        jsr     FloatClr32A6502
        .endm

; -------------------------------------------------------------------------------------------
;
;                                   Set A to 32 bit integer in A
;
; -------------------------------------------------------------------------------------------
FloatSet32A .macro
        jsr     FloatSet32A6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                                   Set A to 32 bit integer in A
;
; -------------------------------------------------------------------------------------------
FloatSet32B .macro
        jsr     FloatSet32B6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                           Copy B to A as 32 bit integer
;
; -------------------------------------------------------------------------------------------
FloatCopy32BA .macro
        jsr     FloatCopy32BA6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                           Copy A to R as 32 bit integer
;
; -------------------------------------------------------------------------------------------
FloatCopy32AR .macro
        jsr     FloatCopy32AR6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                           Copy R to A as 32 bit integer
;
; -------------------------------------------------------------------------------------------
FloatCopy32RA .macro
        jsr     FloatCopy32RA6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                   Add B to A as 32 bit integer, sets N and C
;
; -------------------------------------------------------------------------------------------
FloatAdd32AB .macro
        jsr     FloatAdd32AB6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                   Sub B from A as 32 bit integer, sets N and C
;
; -------------------------------------------------------------------------------------------
FloatSub32AB .macro
        jsr     FloatSub32AB6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                               Shift A right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32A .macro
        jsr     FloatShr32A6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                               Shift B right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32B .macro
        jsr     FloatShr32B6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                               Shift R right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32R .macro
        jsr     FloatShr32R6502
    	.endm
; -------------------------------------------------------------------------------------------
;
;                               Shift A left 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShl32A .macro
        jsr     FloatShl32A6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                               Shift B left 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShl32B .macro
        jsr     FloatShl32B6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                                   Check if A is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32A .macro
        jsr     FloatTest32A6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                                   Check if B is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32B .macro
        jsr     FloatTest32B6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                                   Check if R is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32R .macro
        jsr     FloatTest32R6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                               Negate A, no signs
;
; -------------------------------------------------------------------------------------------
FloatNeg32A .macro
        jsr     FloatNeg32A6502
	   .endm
; -------------------------------------------------------------------------------------------
;
;                                   Push A on the stack
;
; -------------------------------------------------------------------------------------------
FloatPush32A .macro
        jsr     FloatPush32A6502
	   .endm

; -------------------------------------------------------------------------------------------
;
;                                   Pop B off the stack
;
; -------------------------------------------------------------------------------------------
FloatPop32B .macro
        jsr     FloatPop32B6502
	   .endm

; -------------------------------------------------------------------------------------------
;
;                                      Access Macros
;
; -------------------------------------------------------------------------------------------

FloatLoadI .macro
        lda     (\1)
        .endm

FloatLoadIY .macro
        lda     (\1),y
        .endm

; -------------------------------------------------------------------------------------------
;
;                                      Vector Table Creation
;
; -------------------------------------------------------------------------------------------

FloatVector .macro
        .word   (\1) & $FFFF, (\1) >> 16    ; create a 4 byte vector, used for *both*.
        .endm

FloatJumpIX .macro
        jmp     (\1,x)                      ; this may need to be jmp [\1,x] for 65816
        .endm

FloatDo .macro                              ; call command \1
        lda     #FTCMD_\1
        jsr     FloatEntry                  ; likely jsl for 65816
        .endm

FloatExit .macro
        rts                                 ; the final return. Likely rtl for 65816
        .endm
; *******************************************************************************************
; *******************************************************************************************
;
;		Name : 		fp_macros_65816.inc
;		Purpose :	Macros (65816)
;		Date :		20th March 2025
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************


; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      dispatch.asm
;       Purpose :   Dispatch commands
;       Date :      21st March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;       Execute a FP command. Command number in A. CS=> error. Some return a value in A
;
; *******************************************************************************************

FloatEntry:
        cmp     #FTCMD_COUNT                ; illegal command
        bcs     _FEExit                     ; exit with CS.

        stz     floatStackPointer           ; clear stack
        stz     floatBufferSize             ; clear return string.
        stz     floatBufferString

        phx                                 ; save registers, not A
        phy
        asl     a                           ; 4 bytes / entry in jump table
        asl     a
        tax
        jsr     _FECall                     ; so we can return using RTS, local on 65816
        ply                                 ; restore registers other than A
        plx
_FEExit:
        FloatExit                           ; this is RTS or RTL

_FECall:
        FloatJumpIX FloatVectorTable        ; differs on 6502/65816
;
;	This file is automatically generated.
;
FloatVectorTable:
	FloatVector	FloatAdd                       ; 0
	FloatVector	FloatSubtract                  ; 1
	FloatVector	FloatMultiply                  ; 2
	FloatVector	FloatDivide                    ; 3
	FloatVector	FloatIntDivide                 ; 4
	FloatVector	FloatFractional                ; 5
	FloatVector	FloatInteger                   ; 6
	FloatVector	FloatFloatToString             ; 7
	FloatVector	FloatIntegerToDecimalString    ; 8
	FloatVector	FloatIntegerToString           ; 9
	FloatVector	FloatScale10                   ; 10
	FloatVector	FloatStringToInteger           ; 11
	FloatVector	FloatStringToFloat             ; 12
	FloatVector	FloatLogarithmE                ; 13
	FloatVector	FloatExponent                  ; 14
	FloatVector	FloatSquareRoot                ; 15
	FloatVector	FloatSine                      ; 16
	FloatVector	FloatCosine                    ; 17
	FloatVector	FloatTangent                   ; 18
	FloatVector	FloatArcTangent                ; 19

; *******************************************************************************************
; *******************************************************************************************
;
;		Name : 		fp_utility_65816.asm
;		Purpose :	Utility routines and/or macros, 65816 version.
;		Date :		20th March 2025
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************


; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      fp_utility_6502.asm
;       Purpose :   Utility routines and/or macros, 6502 version.
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; -------------------------------------------------------------------------------------------
;
;                                       Clear A to zero
;
; -------------------------------------------------------------------------------------------

FloatClr32A6502:
        stz     floatAMantissa+0
        bra     FloatClr32A6502Continue

; -------------------------------------------------------------------------------------------
;
;                                   Set A to 32 bit integer in A
;
; -------------------------------------------------------------------------------------------

FloatSet32A6502:
        sta     floatAMantissa+0
FloatClr32A6502Continue:
        stz     floatAFlags
        stz     floatAExponent
        stz     floatAMantissa+1
        stz     floatAMantissa+2
        stz     floatAMantissa+3
        rts

; -------------------------------------------------------------------------------------------
;
;                                   Set B to 32 bit integer in A
;
; -------------------------------------------------------------------------------------------

FloatSet32B6502:
        sta     floatBMantissa+0
        stz     floatBFlags
        stz     floatBExponent
        stz     floatBMantissa+1
        stz     floatBMantissa+2
        stz     floatBMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                           Copy B to A as 32 bit integer
;
; -------------------------------------------------------------------------------------------

FloatCopy32BA6502:
        FloatCopyReg floatB,floatA
        rts

; -------------------------------------------------------------------------------------------
;
;                           Copy A to R as 32 bit integer
;
; -------------------------------------------------------------------------------------------

FloatCopy32AR6502:
        FloatCopyReg floatA,floatR
        rts

; -------------------------------------------------------------------------------------------
;
;                           Copy R to A as 32 bit integer
;
; -------------------------------------------------------------------------------------------

FloatCopy32RA6502:
        FloatCopyReg floatR,floatA
        rts

; -------------------------------------------------------------------------------------------
;
;                       Add B to A as 32 bit integer, sets N and C
;
; -------------------------------------------------------------------------------------------
FloatAdd32AB6502:
        clc
        lda     floatAMantissa+0
        adc     floatBMantissa+0
        sta     floatAMantissa+0
        lda     floatAMantissa+1
        adc     floatBMantissa+1
        sta     floatAMantissa+1
        lda     floatAMantissa+2
        adc     floatBMantissa+2
        sta     floatAMantissa+2
        lda     floatAMantissa+3
        adc     floatBMantissa+3
        sta     floatAMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                       Subtract B from A as 32 bit integer, sets N and C
;
; -------------------------------------------------------------------------------------------
FloatSub32AB6502:
        sec
        lda     floatAMantissa+0
        sbc     floatBMantissa+0
        sta     floatAMantissa+0
        lda     floatAMantissa+1
        sbc     floatBMantissa+1
        sta     floatAMantissa+1
        lda     floatAMantissa+2
        sbc     floatBMantissa+2
        sta     floatAMantissa+2
        lda     floatAMantissa+3
        sbc     floatBMantissa+3
        sta     floatAMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Shift A right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32A6502:
        lsr     floatAMantissa+3
        ror     floatAMantissa+2
        ror     floatAMantissa+1
        ror     floatAMantissa+0
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Shift B right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32B6502:
        lsr     floatBMantissa+3
        ror     floatBMantissa+2
        ror     floatBMantissa+1
        ror     floatBMantissa+0
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Shift R right 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShr32R6502:
        lsr     floatRMantissa+3
        ror     floatRMantissa+2
        ror     floatRMantissa+1
        ror     floatRMantissa+0
        rts
; -------------------------------------------------------------------------------------------
;
;                               Negate A mantissa as 32 bit int
;
; -------------------------------------------------------------------------------------------
FloatNeg32A6502:
        sec
        lda     #0
        sbc     floatAMantissa+0
        sta     floatAMantissa+0
        lda     #0
        sbc     floatAMantissa+1
        sta     floatAMantissa+1
        lda     #0
        sbc     floatAMantissa+2
        sta     floatAMantissa+2
        lda     #0
        sbc     floatAMantissa+3
        sta     floatAMantissa+3
        rts

; -------------------------------------------------------------------------------------------
;
;                               Shift A left 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShl32A6502:
        asl     floatAMantissa+0
        rol     floatAMantissa+1
        rol     floatAMantissa+2
        rol     floatAMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                               Shift B left 1 bit, sets C
;
; -------------------------------------------------------------------------------------------
FloatShl32B6502:
        asl     floatBMantissa+0
        rol     floatBMantissa+1
        rol     floatBMantissa+2
        rol     floatBMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Check if A is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32A6502:
        lda     floatAMantissa+0
        ora     floatAMantissa+1
        ora     floatAMantissa+2
        ora     floatAMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Check if B is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32B6502:
        lda     floatBMantissa+0
        ora     floatBMantissa+1
        ora     floatBMantissa+2
        ora     floatBMantissa+3
        rts
; -------------------------------------------------------------------------------------------
;
;                                   Check if R is zero
;
; -------------------------------------------------------------------------------------------
FloatTest32R6502:
        lda     floatRMantissa+0
        ora     floatRMantissa+1
        ora     floatRMantissa+2
        ora     floatRMantissa+3
        rts

; -------------------------------------------------------------------------------------------
;
;                                   Push A on the stack
;
; -------------------------------------------------------------------------------------------
FloatPush32A6502:
        ldy     floatStackPointer
        ldx     #5
_FPLoop:lda     floatA,x
        sta     floatStack,y
        iny
        dex
        bpl     _FPLoop
        sty     floatStackPointer

        rts

; -------------------------------------------------------------------------------------------
;
;                                   Pop B off the stack
;
; -------------------------------------------------------------------------------------------

FloatPop32B6502:
        ldy     floatStackPointer
        ldx     #0
_FPLoop:dey
        lda     floatStack,y
        sta     floatB,x
        inx
        cpx     #6
        bne     _FPLoop
        sty     floatStackPointer
        rts


        ;
        ;       The basic arithmetic operations
        ;
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      add.asm
;       Purpose :   Addition/Subtraction
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                         Subtract iFloat FPB from iFloat FPA
;
; *******************************************************************************************

FloatSubtract:
        pha                                 ; toggle the sign of FPB and add
        lda     floatBFlags
        eor     #$80
        sta     floatBFlags
        pla

; *******************************************************************************************
;
;                       Add iFloat FPB to iFloat FPA (also used for subtract)
;
; *******************************************************************************************

FloatAdd:
        pha                                 ; save registers
        phx
        phy

        lda     floatAExponent              ; check if both integer
        ora     floatBExponent
        beq     _FAInteger                  ; if so, don't need to normalise
        ;
        ;       Check zero.
        ;
        FloatTest32B                        ; check if FPB = 0
        beq     _FAExit                     ; if so, just return FPA.
        FloatTest32A                        ; check if FPA = 0
        bne     _FAFloatingPoint            ; if not, then do FP addition.
        FloatCopy32BA                       ; copy FPB to FPA
        bra     _FAExit                     ; and exit
        ;
        ;       Floating point add/subtract
        ;
_FAFloatingPoint:
        jsr     FloatNormaliseA             ; normalise FPA & FPB
        jsr     FloatNormaliseB
        ;
        ;       Work out the common exponent for the arithmetic.
        ;
        lda     floatAExponent              ; calculate the higher exponent, to X
        tax
        sec
        sbc     floatBExponent              ; signed comparison
        bvc     +
        eor     #$80
+       bpl     +
        ldx     floatBExponent              ; get the lower value.
+
        ;
        ;       Shift both mantissa/exponent to match X in FPA
        ;
-       cpx     floatAExponent              ; reached required exponent (FPA)
        beq     +
        phx
        FloatShr32A                         ; shift right and adjust exponent, preserving the target
        plx
        inc     floatAExponent
        bra     -
+
        ;
        ;       Shift both mantissa/exponent to match X in B
        ;
-       cpx     floatBExponent              ; reached required exponent (FPB)
        beq     +
        phx
        FloatShr32B                         ; shift right and adjust exponent, preserving the target
        plx
        inc     floatBExponent
        bra     -
+
        ;
        ;       Now do the mantissa add/subtract and adjustment, figure out which first.
        ;
_FAInteger:
        lda     floatAFlags                 ; are they different sign flags
        eor     floatBFlags                 ; e.g. the signs are different, it's a subtraction
        bmi     _FASubtraction
_FAAddition:
        ;
        ;       Integer arithmetic : Addition
        ;
        FloatAdd32AB                        ; add FPB to FPA - sign of result is inherited.
        bpl     _FAExit                     ; no overflow, bit 31 of mantissa clear.
        FloatShr32A                         ; fix up the mantissa
        inc     floatAExponent              ; bump the exponent
        bra     _FAExit                     ; and quit.
        ;
        ;       Integer arithmetic : Subtraction
        ;
_FASubtraction:
        FloatSub32AB                        ; subtract FPB from FPA
        bpl     _FAExit                     ; no underflow, then exit.
        FloatNeg32A                         ; negate FPA mantissa
        lda     floatAFlags                 ; toggle the sign flag
        eor     #$80
        sta     floatAFlags
        bra     _FAExit
        ;
        ;       Exit, with check for minus zero
        ;
_FAExit:
        jsr     FloatCheckMinusZero
        ply                                 ; restore registers
        plx
        pla
        clc
        rts

; *******************************************************************************************
;
;           Test FPA for minus zero as we have a sign and magnitude system
;
; *******************************************************************************************

FloatCheckMinusZero:
        lda     floatAFlags                 ; slight increase as mostly +ve
        bpl     _FCMZExit
        FloatTest32A                        ; if a zero mantissa
        bne     _FCMZExit
        lda     floatAFlags                 ; clear the sign bit
        and     #$7F
        sta     floatAFlags
_FCMZExit:
        rts

; *******************************************************************************************
;
;                                   Normalise FPA & FPB
;
; *******************************************************************************************

FloatNormaliseA:
        FloatTest32A                        ; check FPA zero
        beq     _NAExit
-
        lda     floatAMantissa+3            ; check normalised
        and     #$40
        bne     _NAExit
        FloatShl32A
        dec     floatAExponent
        bra     -
_NAExit:
        rts

FloatNormaliseB:
        FloatTest32B                        ; check FPB zero
        beq     _NBExit
-
        lda     floatBMantissa+3            ; check normalised
        and     #$40
        bne     _NBExit
        FloatShl32B
        dec     floatBExponent
        bra     -
_NBExit:
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      multiply.asm
;       Purpose :   Multiplication (int and float)
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                           Multiply iFloat FPA by iFloat FPB
;
; *******************************************************************************************

FloatMultiply:
        pha                                 ; save registers
        phx
        phy
        ;
        ;       Check zero. Ax0 or 0xB => 0 always.
        ;
        FloatTest32A                        ; check if FPA = 0
        beq     _FMExit1                    ; if so, just return FPA
        FloatTest32B                        ; check if FPB = 0
        bne     _FMMultiply                 ; if not, do multiply code
        FloatClear32A                       ; otherwise return zero
_FMExit1:
        ply                                 ; restore registers
        plx
        pla
        clc
        rts
        ;
        ;       Floating point multiply, also works as an integer operation, but if integer overflows
        ;       it will return a float, which can be detected by a non zero exponents
        ;
_FMMultiply:
        clc                                 ; add FPA exponent to FPB exponent
        lda     floatAExponent
        adc     floatBExponent
        pha

        lda     floatAFlags                 ; work out the new sign.
        eor     floatBFlags
        and     #$80
        pha

        FloatCopy32AR                       ; copy FPA into FPR
        FloatClear32A                       ; zero FPA
        ;
        ;       Main multiplication loop. FPA is the total, FPB is the additive multiplies, FPR is the right shifting multiplier.
        ;
_FMMultiplyLoop:
        lda     floatRMantissa+0            ; check LSB of FPR
        and     #1
        beq     _FMNoAdd

        FloatAdd32AB                        ; add FPB to FPA
        bit     floatAMantissa+3            ; did we get an overflow ?
        bpl     _FMNoAdd                    ; no, no overflow shift required.
        ;
        ;       Add overflowed, so shift FPA right rather than doubling FPB. In Integer only this will become a float
        ;
        FloatShr32A                         ; addition on overflow : shift FPA right and bump the exponent.
        inc     floatAExponent              ; this replaces doubling the adder FPB
        bra     _FMShiftR
        ;
        ;       Double FPB, the value being added in.
        ;
_FMNoAdd:
        bit     floatBMantissa+3            ; is it actually possible to double FPB ?
        bvs     _FMCantDoubleB              ; e.g. is bit 30 clear
        FloatShl32B                         ; if it is clear we can just shift it
        bra     _FMShiftR
_FMCantDoubleB:
        FloatShr32A                         ; we can't double FPB so we halve FPA
        inc     floatAExponent              ; this fixes the result up.
        ;
        ;       The usual end of the multiply loop, shift FPR right and loop back if non-zero.
        ;
_FMShiftR:
        FloatShr32R                         ; shift FPR right.
        FloatTest32R                        ; loop back if non-zero
        bne     _FMMultiplyLoop

_FMExit2:
        pla                                 ; update the sign and exponent.
        sta     floatAFlags
        pla
        clc
        adc     floatAExponent
        sta     floatAExponent
        jsr     FloatCheckMinusZero         ; -0 check required here.
        ply                                 ; restore registers
        plx
        pla
        rts
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      divide.asm
;       Purpose :   Division (int and float, which are seperate)
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                             Divide iFloat FPA by iFloat FPB (float)
;                                  (CS on division by zero)
;
; *******************************************************************************************

FloatDivide:
        pha                                 ; save registers
        phx
        phy
        ;
        ;       Check division by zero.
        ;
        FloatTest32B                        ; check if FPB = 0
        bne     _FMFDivide                  ; if not, do divide
        ply                                 ; restore registers
        plx
        pla
        sec
        rts
        ;
        ;       FP Divide
        ;
_FMFDivide:
        jsr     FloatNormaliseA             ; normalise FPA & FPB
        jsr     FloatNormaliseB

        lda     floatAFlags                 ; calculate new sign and push on stack
        eor     floatBFlags
        pha
        ;
        sec                                 ; calculate new exponent
        lda     floatAExponent
        sbc     floatBExponent
        sec
        sbc     #30
        pha

        jsr     _FFDMain                    ; the main float division routine
        FloatCopy32RA                       ; FPA := FPR

        pla                                 ; restore exponent.
        sta     floatAExponent
        pla                                 ; restore sign.
        and     #$80
        sta     floatBFlags
        lda     floatAFlags
        and     #$7F
        ora     floatBFlags
        sta     floatAFlags

        jsr     FloatCheckMinusZero         ; -0 check required here.
        ply                                 ; restore registers
        plx
        pla
        clc                                 ; valid result
        rts
;
;       Main FP Division routine.
;
_FFDMain:
        ldx     #5                          ; clear FPR
_FFDClearR:
        stz     floatRFlags,x
        dex
        bpl     _FFDClearR

        lda     #31                         ; Main loop counter
_FFDLoop:
        pha                                 ; save counter.
        jsr     FloatDivTrySubtract         ; try to subtract
        php                                 ; save the result
        jsr     FloatDivShiftARLeft         ; shift FPA:FPR left one.
        plp                                 ; restore the result
        bcc     _FFDFail                    ; could not subtract
        inc     floatRMantissa+0            ; set bit 0 (cleared by shift left)
_FFDFail:
        pla                                 ; pull and loop
        dec     a
        bne     _FFDLoop
        rts

; *******************************************************************************************
;
;           Divide iFloat A by iFloat B (integer) . Inputs not checked for integer-ness
;                                  (CS on division by zero)
;
; *******************************************************************************************

FloatIntDivide:                             ; it's integer division in the Float package !!
        pha                                 ; save registers
        phx
        phy
        ;
        ;       Check division by zero.
        ;
        FloatTest32B                        ; check if FPB = 0
        bne     _FMDivide                   ; if not, do divide code
        ply                                 ; restore registers
        plx
        pla
        sec
        rts
        ;
        ;       Integer Divide.
        ;
_FMDivide:
        lda     floatAFlags                 ; calculate new sign and push on stack
        eor     floatBFlags
        pha
        jsr     _FIDMain                    ; the main integer division routine
        lda     floatAMantissa              ; save the LSB of the remainder for later
        sta     floatModulusLowByte
        FloatCopy32RA                       ; FPA := FPR
        pla                                 ; restore sign.
        and     #$7F
        sta     floatAFlags

        jsr     FloatCheckMinusZero         ; -0 check required here.
        ply                                 ; restore registers
        plx
        pla
        clc                                 ; valid result
        rts
;
;       Main integer division routine.
;
_FIDMain:
        FloatCopy32AR                       ; FPR := FPA
        FloatClear32A                       ; FPA := 0
        lda     #32                         ; Main loop counter
_FIDLoop:
        pha                                 ; save counter.
        jsr     FloatDivShiftARLeft         ; shift FPA:FPR left one.
        jsr     FloatDivTrySubtract         ; try to subtract
        bcc     _FIDFail                    ; could not subtract
        inc     floatRMantissa+0            ; set bit 0 (cleared by shift left)
_FIDFail:
        pla                                 ; pull and loop
        dec     a
        bne     _FIDLoop
        rts

; *******************************************************************************************
;
;                                   Shift FPA:FPR left one
;
; *******************************************************************************************

FloatDivShiftARLeft:
        asl     floatRMantissa+0            ; do the lower byte ....
        rol     floatRMantissa+1
        rol     floatRMantissa+2
        rol     floatRMantissa+3
        rol     floatAMantissa+0            ; the upper byte. This is only used in divide so
        rol     floatAMantissa+1            ; it's not really worth optimising.
        rol     floatAMantissa+2
        rol     floatAMantissa+3
        rts

; *******************************************************************************************
;
;                       Try to subtract FPB from FPA. If it works, return CS
;
; *******************************************************************************************

FloatDivTrySubtract:
        FloatSub32AB                        ; subtract FPB from FPA
        bcs     _FDTSExit                   ; it worked okay.
        FloatAdd32AB                        ; failed, so add it back
        clc                                 ; carry must be clear.
_FDTSExit:
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      integer.asm
;       Purpose :   Integer part of a number
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                           Get integer part of FPA
;
; *******************************************************************************************

FloatInteger:
        pha                                 ; save registers
        phx
        phy

        lda     floatAExponent              ; exponent >= 0, then already integer
        bpl     _FIExit
        FloatTest32A                        ; zero, then integer
        beq     _FIExit
        jsr     FloatNormaliseA             ; Normalise FPA
_FIConvert:
        lda     floatAExponent              ; exponent sill negative ?
        bpl     _FIExit
        FloatShr32A                         ; keep shifting right until exponent = 0
        inc     floatAExponent
        bra     _FIConvert
_FIExit:
        jsr     FloatCheckMinusZero         ; -0 check required here.
        ply                                 ; restore registers
        plx
        pla
        clc
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      fractional.asm
;       Purpose :   Fractional part of a number
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                           Get fractional part of FPA
;
; *******************************************************************************************

FloatFractional:
        pha                                 ; save registers
        phx
        phy
        jsr     FloatNormaliseA             ; normalise FPA
        lda     floatAFlags                 ; take absolute value of FPA
        and     #$7F
        sta     floatAFlags

        lda     floatAExponent              ; check exponent
        bpl     _FFZero                     ; if >= 0 then return zero.
        cmp     #$E0+1                      ; if it is <= -32 ($E0) it is already fractional, e.g. $80...$E0 inclusive
        bcc     _FFExit
        clc
        adc     #32                         ; this is the number of bits to strip - must be >= 0 (from MSB)
        tax                                 ; which goes into X.
        ldy     #3                          ; offset into a Mantissa, starts with MSB
_FFStripBits:
        cpx     #0                          ; done ?
        beq     _FFExit
        cpx     #8                          ; 8 or more bits to strip.
        bcs     _FFStripByte                ; do a byte at a time.

        lda     floatAMantissa,y            ; do the final bit strip.
        and     _FFBitStrip,x
        sta     floatAMantissa,y
        bra     _FFExit                     ; and exit

_FFStripByte:
        lda     #0                          ; strip a whole byte
        sta     floatAMantissa,y
        dey                                 ; next most significant byte
        txa                                 ; subtract 8 from the todo count
        sec
        sbc     #8
        tax
        bra     _FFStripBits                ; and go round again.

_FFZero:
        FloatClear32A                       ; return 0
_FFExit:
        ply                                 ; restore registers
        plx
        pla
        clc
        rts

_FFBitStrip:
        .byte   $FF                         ; 0
        .byte   $7F                         ; 1
        .byte   $3F                         ; 2
        .byte   $1F                         ; 3
        .byte   $0F                         ; 4
        .byte   $07                         ; 5
        .byte   $03                         ; 6
        .byte   $01                         ; 7
        .byte   $00                         ; 8
        ;
        ;       Convert to/from strings.
        ;
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      inttostr.asm
;       Purpose :   Integer to String conversion.
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;           Convert the integer in FPA (not tested) to Decimal in the string buffer
;
; *******************************************************************************************

FloatIntegerToDecimalString:
        phy
        ldy     #10
        jsr     FloatIntegerToString
        ply
        rts

; *******************************************************************************************
;
;                   Convert the integer in FPA to a String in Base Y
;
; *******************************************************************************************

FloatIntegerToString:
        pha                                 ; save registers
        phx
        phy
        sty     floatBaseConvert            ; save the base to convert

        stz     floatBufferSize             ; clear the buffer, both NULL terminated and length prefixed.
        stz     floatBufferString

        bit     floatAFlags                 ; -ve ?
        bpl     _FITSPositive
        stz     floatAFlags                 ; not really required :)
        lda     #'-'                        ; output -
        jsr     FloatAddCharacterToBuffer
_FITSPositive:
        jsr     _FITSRecursive
        ply                                 ; restore registers
        plx
        pla
        clc
        rts

_FITSRecursive:
        lda     floatBaseConvert            ; divide by the base, put in B
        FloatSet32B
        jsr     FloatIntDivide              ; integer division.
        lda     floatModulusLowByte         ; get the low byte, the remainder and save it.
        pha
        FloatTest32A                        ; zero ?
        beq     _FITSZero
        jsr     _FITSRecursive              ; if not, keep going.
_FITSZero:
        pla
        cmp     #10                         ; hexadecimal or higher ?
        bcc     _FITSNotHex
        clc
        adc     #7
_FITSNotHex:
        clc                                 ; make ASCII.
        adc     #48
        jsr     FloatAddCharacterToBuffer   ; add to buffer and exit
        rts

; *******************************************************************************************
;
;                   Add Character to Buffer (also used by FloatToString)
;
; *******************************************************************************************

FloatAddCharacterToBuffer:
        phx
        ldx     floatBufferSize             ; current size
        sta     floatBufferString,x         ; write character out
        stz     floatBufferString+1,x       ; make ASCIIZ
        inc     floatBufferSize             ; bump character count
        plx
        rts
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      floattostr.asm
;       Purpose :   Float to string conversion
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;           Convert the float in FPA (not tested) to the string buffer
;
; *******************************************************************************************

FloatFloatToString:
        pha
        phx
        phy
        lda     floatAExponent              ; is it actually an integer ?
        bne     _FFTSFloat
        jsr     FloatIntegerToDecimalString ; if so, just do the integer conversion
        ply
        plx
        pla
        clc
        rts

_FFTSFloat:
        FloatPush32A                        ; push A on the stack
        jsr     FloatInteger                ; convert to an integer part.
        jsr     FloatIntegerToDecimalString ; and convert to a string.
        lda     #"."                        ; add decimal point
        jsr     FloatAddCharacterToBuffer

_FFTSFracLoop:
        FloatPop32B                         ; pop current value off the stack.
        FloatTest32B                        ; is it zero, if so then exit.
        beq     _FFTSExit
        FloatCopy32BA                       ; put the value in A
        jsr     FloatFractional             ; take the fractional part.
        jsr     FloatNormaliseA             ; normalise it.
        lda     floatBExponent              ; if it is a small number stop here
        cmp     #$DE
        bcc     _FFTSExit
        lda     floatBufferSize             ; too long a decimal
        cmp     #15
        bcs     _FFTSExit
        lda     #10                         ; multiply that by 10.
        FloatSet32B
        jsr     FloatMultiply
        FloatPush32A                        ; save result on the stack for the next time round.
        jsr     FloatInteger                ; convert to an integer
        lda     floatAMantissa+0            ; output as a digit
        ora     #48
        jsr     FloatAddCharacterToBuffer
        bra     _FFTSFracLoop               ; and go round again.

_FFTSExit:
        ldx     floatBufferSize             ; check for trailing zero
        lda     floatBufferString-1,x       ; ends in a zero, but not .0
        cmp     #"0"
        bne     _FFTSNotTrailingZero
        lda     floatBufferString-2,x
        cmp     #"."
        beq     _FFTSNotTrailingZero
        dec     floatBufferSize             ; patch up.
        stz     floatBufferString-1,x
_FFTSNotTrailingZero:
        ply
        plx
        pla
        clc
        rts


; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      strtoint.asm
;       Purpose :   String to Integer conversion.
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;       (floatZ0) points to a numeric string, extract decimal integer from it to FPA (no minus
;       prefix). Return CS on error (overflow, no number), and return in A the number of
;       characters removed.
;
; *******************************************************************************************

FloatStringToInteger:
        phx
        phy

        FloatClear32A                       ; set the F{A register to zero.
        ldy     #0                          ; start from here.
        FloatLoadIY floatZ0                 ; get and push sign
        pha
        cmp     #"-"                        ; if -ve skip it
        bne     _FSILoop
        iny
_FSILoop:
        FloatLoadIY floatZ0                 ; get next character
        cmp     #'0'                        ; check validity
        bcc     _FSIExit
        cmp     #'9'+1
        bcs     _FSIExit

        lda     #10                         ; multiply FPA by 10
        FloatSet32B
        jsr     FloatMultiply
        FloatLoadIY floatZ0                 ; add number.
        iny
        and     #$0F
        FloatSet32B
        jsr     FloatAdd
        lda     floatAExponent              ; check still an integer.
        beq     _FSILoop
_FSIFail:                                   ; overflow, or no digits at all.
        pla                                 ; throw sign
        sec
        lda     #0                          ; return zero consumed as error.
        ply                                 ; restore registers
        plx
        rts

_FSIExit:
        pla                                 ; get sign.
        cmp     #"-"                        ; was it -ve
        bne     _FSINotNegative
        lda     #$80                        ; set sign bit
        sta     floatAFlags
_FSINotNegative:
        tya                                 ; check consumed at least one digit ? count in Y
        beq     _FSIFail
        ply                                 ; restore registers
        plx
        clc
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      strtofloat.asm
;       Purpose :   Convert value at (floatZ0) to a floating point number in A
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                   Convert string at (floatZ0) into FPA. Return CS on error.
;        Behaves like VAL() in that it does not have a problem with ending bad characters
;
; *******************************************************************************************

FloatStringToFloat:
        pha                                 ; save registers
        phx
        phy
        ;
        ;       Process possible preceding '-'
        ;
        ldy     #0
        lda     (floatZ0)                   ; get, and push, the first character.
        eor     #"-"                        ; will be $00 if it is '-', non zero otherwise
        beq     _FSTFNoFlip
        lda     #$80                        ; $00 => '-', $80 => positive
_FSTFNoFlip:
        eor     #$80                        ; now a sign bit.
        pha                                 ; save it.
        beq     _FSTFNoMinus                ; if was +ve don't bump
        lda     #1
        jsr     _FSTFAddToPointer
_FSTFNoMinus:
        ;
        ;       The integer part, if there is one.
        ;
        FloatClear32A                       ; zero FPA
        ldy     #1                          ; this is the amount to skip if decimal.
        FloatLoadI floatZ0                  ; is it '.xxxxx' VAL(".12") => 0.12
        cmp     #"."                        ; if so, convert to decimal.
        beq     _FSTFDecimalPart

        jsr     FloatStringToInteger        ; get the integer part first.
        bcs     _FSTFExit                   ; bad number.
        tay                                 ; count of characters in Y
        FloatLoadIY floatZ0                 ; what follows is '.'
        cmp     #'.'                        ; if not, then exit with a whole number and carry clear
        bne     _FSTFExitOkay
        iny
        ;
        ;       The fractional part, if there is one.
        ;
_FSTFDecimalPart:
        tya                                 ; point floatZ0 to post decimal point bit.
        jsr     _FSTFAddToPointer
        FloatLoadI floatZ0                  ; character following, if illegal just ignore it.
        cmp     #'0'                        ; VAL("12.") => 12
        bcc     _FSTFExitOkay
        cmp     #'9'+1
        bcs     _FSTFExitOkay
        FloatPush32A                        ; push FPA on the stack.
        jsr     FloatStringToInteger        ; get the Decimal Point bit, divisor is in A
        bcs     _FSTFExit                   ; bad number.
        tay                                 ; put in Y
        jsr     FloatScale10                ; divide by 10^Y
        FloatPop32B                         ; FPA is fractional part, FPB integer part
        jsr     FloatAdd                    ; add them together.
_FSTFExitOkay:
        pla                                 ; get flags
        sta     floatAFlags
        clc                                 ; result is okay.
_FSTFExit:
        ply                                 ; restore registers
        plx
        pla
        rts

; *******************************************************************************************
;
;                       Add A to the pointer, supports 6502 and 65816
;
; *******************************************************************************************

_FSTFAddToPointer:
        clc
        adc     floatZ0
        sta     floatZ0
        bcc     _FSTFNoCarry
        inc     floatZ0+1
        bne     _FSTFNoCarry
        inc     floatZ0+2
_FSTFNoCarry:
        rts


; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      scale10.asm
;       Purpose :   Divide A by 10^A
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                                       Divide FPA by 10^Y
;
; *******************************************************************************************

FloatScale10:
        pha
        phx
        phy

        tya                                 ; get divider
        cmp     #16                         ; divider >= 16
        bcs     _FSCZero                    ; return zero.

        sta     floatBMantissa              ; temporary store, we want to x 3
        asl                                 ; x 2
        adc     floatBMantissa              ; x 3
        asl                                 ; x 6
        tax
        ldy     #0                          ; index into FPB
_FSCCopy:
        lda     FloatScalarTable,x          ; copy it
        sta     floatBFlags,y
        inx
        iny
        cpy     #6                          ; copied 6 bytes of float data
        bne     _FSCCopy
        jsr     FloatMultiply               ; the scalars are 1, 0.1 etc.
        bra     _FSCExit

_FSCZero:
        FloatClear32A                       ; set the FPA register to zero.
_FSCExit:
        ply                                 ; restore registers
        plx
        pla
        clc
        rts

;
;	This file is automatically generated.
;
FloatScalarTable:
	.byte $00,$00,$01,$00,$00,$00 ; 1 (1)
	.byte $00,$de,$66,$66,$66,$66 ; 0.1 (0.09999999997671694)
	.byte $00,$db,$1f,$85,$eb,$51 ; 0.01 (0.010000000002037268)
	.byte $00,$d8,$4c,$37,$89,$41 ; 0.001 (0.0010000000002037268)
	.byte $00,$d4,$ac,$8b,$db,$68 ; 0.0001 (9.999999997489795e-05)
	.byte $00,$d1,$24,$d6,$e2,$53 ; 0.00001 (1.0000000003174137e-05)
	.byte $00,$ce,$83,$de,$1b,$43 ; 0.000001 (1.000000000139778e-06)
	.byte $00,$ca,$6b,$ca,$5f,$6b ; 0.0000001 (1.0000000000287557e-07)
	.byte $00,$c7,$89,$3b,$e6,$55 ; 0.00000001 (1.0000000001675335e-08)
	.byte $00,$c4,$a1,$2f,$b8,$44 ; 0.000000001 (1.0000000003410059e-09)
	.byte $00,$c0,$67,$7f,$f3,$6d ; 0.0000000001 (9.999999997989048e-11)
	.byte $00,$bd,$86,$ff,$f5,$57 ; 0.00000000001 (1.0000000000699553e-11)
	.byte $00,$ba,$05,$66,$5e,$46 ; 0.000000000001 (1.000000000239362e-12)
	.byte $00,$b6,$a1,$09,$97,$70 ; 0.0000000000001 (9.999999999217246e-14)
	.byte $00,$b3,$1b,$6e,$12,$5a ; 0.00000000000001 (1.0000000003187713e-14)
	.byte $00,$b0,$7c,$be,$0e,$48 ; 0.000000000000001 (1.0000000003187713e-15)
	.byte $00,$ac,$5f,$ca,$4a,$73 ; 0.0000000000000001 (9.999999998017834e-17)
        ;
        ;       Taylor series functions.
        ;
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      utility.asm
;       Purpose :   Utility polynomial functions
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;           Evaluate polynomial at offset X from PolynomialData using value in FPA
;                                       (Horner's method)
;
; *******************************************************************************************

FloatEvaluatePoly:
        lda     PolynomialData,x            ; get the number to do
        inx                                 ; point to first number.
        sta     polyCoefficientCount        ; count of numbers

        ldy     #5                          ; copy poly x to workspace
_PECopy1:
        lda     floatA,y
        sta     polyTempFloat,y
        dey
        bpl     _PECopy1

        FloatClear32A                       ; set FPA to zero.

_PEEvaluateLoop:
        ldy     #5                          ; copy X back to FPB
_PECopy2:
        lda     polyTempFloat,y
        sta     floatB,y
        dey
        bpl     _PECopy2
        jsr     FloatMultiply               ; and multiply into FPA

        ldy     #0                          ; copy the next coefficient into FPB
_PECopy3:
        lda     PolynomialData,x
        sta     floatB,y
        inx
        iny
        cpy     #6
        bne     _PECopy3

        jsr     FloatAdd                    ; and add into FPB

        dec     polyCoefficientCount        ; do for all coefficients
        bne     _PEEvaluateLoop

        rts

; *******************************************************************************************
;
;                       Load Floating Point value, address following to FPA/FPB.
;
; *******************************************************************************************

PolyConstantToA .macro
        lda     #\1-FloatConst_1Div2Pi
        jsr     PolyConstantToACode
        .endm

PolyConstantToB .macro
        lda     #\1-FloatConst_1Div2Pi
        jsr     PolyConstantToBCode
        .endm

PolyConstantToACode:
        phx
        phy
        tax
        ldy     #0
_PCACLoop:
        lda     FloatConst_1Div2Pi,x
        sta     floatA,y
        inx
        iny
        cpy     #6
        bne     _PCACLoop
        ply
        plx
        rts

PolyConstantToBCode:
        phx
        phy
        tax
        ldy     #0
_PCACLoop:
        lda     FloatConst_1Div2Pi,x
        sta     floatB,y
        inx
        iny
        cpy     #6
        bne     _PCACLoop
        ply
        plx
        rts

;
;	This file is automatically generated.
;
PolynomialData:

;
;	 Polynomial to evaluate Log
;
PolynomialLogData:
	.byte	8
	.byte	$00,$e0,$bd,$65,$2b,$6f ; 0.43425594189
	.byte	$00,$00,$00,$00,$00,$00 ; 0
	.byte	$00,$e1,$b2,$85,$cd,$49 ; 0.57658454124
	.byte	$00,$00,$00,$00,$00,$00 ; 0
	.byte	$00,$e1,$8b,$49,$1c,$7b ; 0.96180075919
	.byte	$00,$00,$00,$00,$00,$00 ; 0
	.byte	$00,$e3,$90,$1d,$55,$5c ; 2.8853900731
	.byte	$80,$e1,$00,$00,$00,$40 ; -0.5

;
;	 Polynomial to evaluate Exp
;
PolynomialExpData:
	.byte	8
	.byte	$00,$d2,$2b,$1f,$2c,$5a ; 2.1498763701e-05
	.byte	$00,$d5,$8e,$59,$3f,$4b ; 0.00014352314037
	.byte	$00,$d8,$c3,$71,$f7,$57 ; 0.0013422634825
	.byte	$00,$db,$15,$0e,$c2,$4e ; 0.0096140170135
	.byte	$00,$dd,$05,$ac,$ac,$71 ; 0.05550512686
	.byte	$00,$df,$e3,$f3,$fe,$7a ; 0.2402263846
	.byte	$00,$e1,$08,$0c,$b9,$58 ; 0.69314718618
	.byte	$00,$00,$01,$00,$00,$00 ; 1.0

;
;	 Polynomial to evaluate Sine
;
PolynomialSineData:
	.byte	5
	.byte	$00,$d5,$22,$0d,$1e,$54 ; 0.00016044118478735978
	.byte	$80,$da,$3a,$b3,$b4,$4c ; -0.004681754135318687
	.byte	$00,$de,$9e,$f1,$9a,$51 ; 0.07969262624616703
	.byte	$80,$e1,$99,$f3,$ae,$52 ; -0.6459640975062462
	.byte	$00,$e2,$51,$ed,$87,$64 ; 1.5707963267948966

;
;	 Polynomial to evaluate Arctan
;
PolynomialArctanData:
	.byte	10
	.byte	$80,$dd,$f3,$1a,$ca,$6b ; -0.05263157894736842
	.byte	$00,$dd,$78,$78,$78,$78 ; 0.058823529411764705
	.byte	$80,$de,$44,$44,$44,$44 ; -0.06666666666666667
	.byte	$00,$de,$4f,$ec,$c4,$4e ; 0.07692307692307693
	.byte	$80,$de,$d1,$45,$17,$5d ; -0.09090909090909091
	.byte	$00,$de,$72,$1c,$c7,$71 ; 0.1111111111111111
	.byte	$80,$df,$49,$92,$24,$49 ; -0.14285714285714285
	.byte	$00,$df,$66,$66,$66,$66 ; 0.2
	.byte	$80,$e0,$55,$55,$55,$55 ; -0.3333333333333333
	.byte	$00,$00,$01,$00,$00,$00 ; 1.0
; this file is automatically generated
;
;	This file is automatically generated.
;
FloatConst_1Div2Pi:
	.byte $00,$df,$b7,$c1,$7c,$51 ; 1/(2*math.pi) (0.15915494307409972)
;
;	This file is automatically generated.
;
FloatConst_PiDiv2:
	.byte $00,$e2,$51,$ed,$87,$64 ; math.pi/2 (1.5707963267341256)
;
;	This file is automatically generated.
;
FloatConst_Log2:
	.byte $00,$e1,$fc,$0b,$b9,$58 ; math.log(2) (0.6931471806019545)
;
;	This file is automatically generated.
;
FloatConst_Log2_E:
	.byte $00,$e2,$95,$1d,$55,$5c ; math.log(math.e,2) (1.4426950411871076)
;
;	This file is automatically generated.
;
FloatConst_Sqr2:
	.byte $00,$e2,$9a,$79,$82,$5a ; math.sqrt(2) (1.4142135623842478)
;
;	This file is automatically generated.
;
FloatConst_MinusSqr2:
	.byte $80,$e2,$9a,$79,$82,$5a ; -math.sqrt(2) (-1.4142135623842478)
;
;	This file is automatically generated.
;
FloatConst_Sqr0_5:
	.byte $00,$e1,$9a,$79,$82,$5a ; math.sqrt(0.5) (0.7071067811921239)
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      sinecosine.asm
;       Purpose :   Sine/Cosine evaluation
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                       Cosine calculation of FPA (in Radians)
;
; *******************************************************************************************

FloatCosine:
        pha
        phx
        phy
        PolyConstantToB FloatConst_PiDiv2   ; add Pi/2
        jsr     FloatAdd
        jsr     FloatSine                   ; calculate sin(x+pi/2)
        ply
        plx
        pla
        clc
        rts

; *******************************************************************************************
;
;                       Sine calculation of FPA (in Radians)
;
; *******************************************************************************************

FloatSine:
        pha
        phx
        phy

        lda     floatAFlags                 ; save original sign
        sta     polySign
        and     #$7F
        sta     floatAFlags                 ; take absolute value
        ;
        ;       Divide FPA by 2.Pi and take fractional part, forcing result into the '360' range
        ;
        PolyConstantToB FloatConst_1Div2Pi  ; multiply by 1 / (2.Pi) (e.g. divide by 2.Pi)
        jsr     FloatMultiply
        jsr     FloatFractional             ; take the fractional part.
        ;
        ;       Rounded into 0-360 (in scaled radians), so x 4 to get the quadrant (0=0-90,1=90-180,2=180-270,3=270-360)
        ;
        inc     floatAExponent              ; x 2
        inc     floatAExponent              ; x 4
        FloatPush32A                        ; save this value
        jsr     FloatInteger
        lda     floatAMantissa+0            ; get the quadrant.
        pha                                 ; save for later
        cmp     #2                          ; quadrant 2 + 3, negate the result
        bcc     _PSNotQ23
        lda     polySign
        eor     #$80
        sta     polySign
_PSNotQ23:
        ;
        ;       Work out the fractional part and adjust for quadrants 1 & 3
        ;
        FloatPop32B                         ; get the 4 x value back to B
        FloatCopy32BA                       ; copy to A.
        jsr     FloatFractional             ; fractional part, not quadrant
        pla                                 ; restore the quadrant
        and     #1                          ; is it quadrant 1 or 3
        beq     _PSNotQ13
        lda     #$80                        ; make FPA -x (calculating 1-x)
        sta     floatAFlags
        lda     #1                          ; B = 1, so -x + 1 being done here.
        FloatSet32B
        jsr     FloatAdd
_PSNotQ13:
        ;
        ;       Save FPA for end multiply
        ;
        FloatPush32A                        ; save FPA
        ;
        ;       Calculate FPA^2
        ;
        FloatPush32A                        ; square FPA - copy to FPB (slowly) and multiply
        FloatPop32B
        jsr     FloatMultiply

        ;
        ;       Apply the polynomial and multiply by the saved value.
        ;
        ldx     #PolynomialSineData-PolynomialData
        jsr     FloatEvaluatePoly
        FloatPop32B                         ; now multiply by the original value
        jsr     FloatMultiply

        lda     polySign                    ; get original sign
        bpl     _PSExit
        lda     floatAFlags                 ; if was -ve negate the result.
        eor     #$80
        sta     floatAFlags
_PSExit:
        ply
        plx
        pla
        clc
        rts
; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      tangent.asm
;       Purpose :   Tangent evaluation
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                   Tangent calculation of FPA (in Radians). Return CS on error
;
; *******************************************************************************************

FloatTangent:
        pha
        phx
        phy

        FloatPush32A                        ; save FPA on stack
        jsr     FloatCosine                 ; FPA is cos(x)
        FloatPop32B                         ; FPA is cos(x) FPB (x)
        FloatPush32A                        ; FPB is x, cos(x) on stack
        FloatCopy32BA                       ; FPA is x, cos(x) on stack
        jsr     FloatSine                   ; FPA is sin(x), cos(x) on stack
        FloatPop32B                         ; FPA is sin(x), FPB is cos(x)

        FloatTest32B                        ; check cos(x) is zero.
        sec                                 ; if so exit with carry set.
        beq     _PTExit
        jsr     FloatDivide                 ; work out tangent
        clc                                 ; no error.
_PTExit:
        ply
        plx
        pla
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      logarithm.asm
;       Purpose :   Natural logarithm evaluation
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                       Logarithm calculation of FPA. Return CS on error
;
; *******************************************************************************************

FloatLogarithmE:
        pha
        phx
        phy


        lda     floatAFlags                 ; if negative, it's bad
        sec                                 ; so return with CS.
        bmi     _PLEExit

        jsr     FloatNormaliseA             ; normalise, might be integer

        ;
        ;       Extract the exponent, as a power of 2.
        ;
        lda     floatAExponent              ; work out the shift
        sec
        sbc     #$E1                        ; $E1 normalised is the required exponent offset
        pha                                 ; save on stack.

        lda     #$E1                        ; force into range 0.5-1
        sta     floatAExponent
        ;
        ;       Add square root of 0.5
        ;
        PolyConstantToB     FloatConst_Sqr0_5
        jsr     FloatAdd
        ;
        ;       Divide into -(square root of 2)
        ;
        FloatPush32A
        FloatPop32B
        PolyConstantToA     FloatConst_MinusSqr2
        jsr     FloatDivide
        ;
        ;       Add 1 (so calculating 1-root(2)/(x+root(0.5)))
        ;
        lda     #1
        FloatSet32B
        jsr     FloatAdd
        ;
        ;       Apply the polynomial
        ;
        ldx     #PolynomialLogData-PolynomialData
        jsr     FloatEvaluatePoly
        ;
        ;       Add the exponent offset
        ;
        pla                                 ; Set A to the exponent offset.
        FloatSet32B
        jsr     FloatAdd

        PolyConstantToB FloatConst_Log2     ; multiply by Log(2)
        jsr     FloatMultiply

        clc
_PLEExit:
        ply
        plx
        pla
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      exponent.asm
;       Purpose :   Exponent evaluation
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                                   Calculation of e^FPA
;
; *******************************************************************************************

FloatExponent:
        pha
        phx
        phy
        ;
        ;       Save sign, take absolute value
        ;
        lda     floatAFlags
        sta     polySign
        and     #$7F
        sta     floatAFlags
        ;
        ;       Multiply FPA by log2 e
        ;
        PolyConstantToB FloatConst_Log2_E   ; multiply by log2 e
        jsr     FloatMultiply
        ;
        ;       Extract the integer part.
        ;
        FloatPush32A                        ; push FPA as we want it restored after this bit.
        jsr     FloatInteger                ; take and save the integer part
        lda     floatAMantissa+0
        sta     polyExponentTemp
        FloatPop32B
        FloatCopy32BA
        jsr     FloatFractional             ; extract the fractional part
        ;
        ;       Handle -ve values in original FPA. Negate the exponent and the value for x
        ;
        bit     polySign
        bpl     _PENotNegative

        sec                                 ; negate the exponent
        lda     #0
        sbc     polyExponentTemp
        sta     polyExponentTemp

        lda     #$80                        ; make FPA negative
        sta     floatAFlags

_PENotNegative:
        ;
        ;       Take fractional part of FPA and calculate the Polynomial (which is 2^x, not the standard exp() taylor series)
        ;
        ldx     #PolynomialExpData-PolynomialData
        jsr     FloatEvaluatePoly
        ;
        ;       Add the exponent extracted earlier
        ;
        clc
        lda     polyExponentTemp
        adc     floatAExponent
        sta     floatAExponent

        ply
        plx
        pla
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      squareroot.asm
;       Purpose :   Square root function
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                       Calculate the square root of FPA. CS on error
;
; *******************************************************************************************

FloatSquareRoot:
        pha
        phx
        phy
        bit     floatAFlags                 ; negative
        sec
        bmi     _PSRExit                    ; if so exit with carry set

        jsr     FloatLogarithmE             ; Log(FPA)
        dec     floatAExponent              ; / 2
        jsr     FloatExponent               ; Exp(FPA)
        clc
_PSRExit:
        ply
        plx
        pla
        rts

; *******************************************************************************************
; *******************************************************************************************
;
;       Name :      arctangent.asm
;       Purpose :   ArcTangent evaluation
;       Date :      20th March 2025
;       Author :    Paul Robson (paul@robsons.org.uk)
;
; *******************************************************************************************
; *******************************************************************************************

; *******************************************************************************************
;
;                 ArcTangent calculation of FPA (in Radians). Return CS on error
;
; *******************************************************************************************

FloatArcTangent:
        pha
        phx
        phy
        jsr     FloatNormaliseA             ; normalise A so we can compare >= 1

        lda     floatAFlags                 ; save the current sign of FPA
        sta     polySign
        and     #$7F
        sta     floatAFlags                 ; take absolute value of A

        ;
        ;       if FPA >= 1.0, take reciprocal of FPA
        ;
        stz     polyFlag                    ; clear the adjust flag.
        lda     floatAExponent              ; is the exponent >= $E2 , this means >= 1
        bpl     _PATAdjust                  ; definitely > 1 :)
        cmp     #$E2                        ; $E2..$FF are also > 1
        bcc     _PATNotAdjust
_PATAdjust:
        FloatPush32A                        ; copy FPA to FPB
        FloatPop32B
        lda     #1                          ; FPA = 1, FPB = x
        FloatSet32A
        jsr     FloatDivide                 ; take reciprocal
        inc     polyFlag                    ; set the adjust flag
_PATNotAdjust:
        ;
        ;       Save FPA for end multiply
        ;
        FloatPush32A                        ; save FPA
        ;
        ;       Calculate FPA^2
        ;
        FloatPush32A                        ; square FPA - copy to FPB (slowly) and multiply
        FloatPop32B
        jsr     FloatMultiply
        ;
        ;       Apply the polynomial and multiply by the saved value.
        ;
        ldx     #PolynomialArctanData-PolynomialData
        jsr     FloatEvaluatePoly
        FloatPop32B                         ; now multiply by the original value
        jsr     FloatMultiply
        ;
        ;       If adjusted subtract result from Pi/2
        ;
        lda     polyFlag
        beq     _PATNoFixup

        lda     floatAFlags                 ; FPA = -FPA
        eor     #$80
        sta     floatAFlags
        PolyConstantToB FLoatConst_PiDiv2   ; FPB = Pi/2
        jsr     FloatAdd
_PATNoFixup:
        ;
        ;       Restore sign
        ;
        lda     polySign                    ; restore the original sign
        sta     floatAFlags

        ply
        plx
        pla
        clc
        rts


