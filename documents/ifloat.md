# IFloat Module

This document describes how to use the integer/floating point module and how it works. The module provides floating point and integer mathematics, including taylor series polynomials evaluation of logarithmic values and trigonometry.  It has a 32 bit mantissa.

Prerequisites are Python and 64tass. (The main problem with other assemblers would be the macros)

The implementation is currently for the 65C02 only, but it should run on a 65816 and the relevant parts are converted to macros so it should be fairly easy to get it running on such hardware.

There are Python versions of the algorithms in the ifloat-reference directory which are slightly easier to understand, especially the somewhat eccentric multiply code.

## What is an iFloat ?

So the idea of the "iFloat" came from a thought experiment. Most floating point implementations work on a floating point being the result of a **m. 2 ^ e** expression where m is the mantissa and e is the exponent. 

In most implementations m is 0.5-1.0 as a fractional binary and e is -128..127 (because of byte storage)

The iFloat has an integer mantissa. So it is the same, except that the mantissa is an integer from (in say 32 bit floats) $00000000-$7FFFFFFF 

The "trick" is that when the exponent is zero the mantissa has the same value as its integer equivalent.  

This means that if you are (say) adding two integers, you don't have to normalise, find a common exponent and add. You just add them. This offers significant speed ups for a processor like the 65C02 where such operations are time consuming. 

In this implementation, int and float are not different ; they are just handled differently.

### Issues

There are two issues

1. Because it is a sign and magnitude design, there is no $80000000 value in integer mode, it will be a float because it is out of the integer range, which you would get in a 32 bit two's complement integer. 
2. Because the exponent is a larger, sometimes much larger value, the range is more skewed to very large numbers. This is quite at the extremes ; the range of an iFloat in 32 bits is  2^-128 to $7FFFFFFF * 2^127 , which is 2.93.10^-39 to  3.65*10^47 

## The module

The module is in the source subdirectory, however, all the files are stuck together and placed in build in the file ifloat.library, which is generated by the makefile in the source or the root. This file is included in the repository however. It can just be included as a file.

It does involve declaring two constants 'zeroPageSpace' and 'codeSpace'. 

At the time of writing, this involves the use of 15 bytes of zero page, and 73 bytes of storage. It is possible to move the two main registers 'A' and 'B' to non zero page storage, which will reduce the requirement to 3 bytes of zero page (storage being 85) but this will increase the size of the code and slow it down.

All used memory can be reused by other code as temporary storage.

## The functionality

There are two registers, known as 'A' and 'B', with the labels floatA and floatB. Each is six bytes long and have the following usage.

| Offset | Contents                                          |
| :----: | ------------------------------------------------- |
|   0    | Sign bit, kept in the bit 7 of this byte          |
|   1    | Exponent, in 2's complement form.                 |
|  2..5  | 32 bit Mantissa, LSB first, should be 0-$7FFFFFFF |

For packing purposes this can be reduced to 5 bytes, as the sign bit can be stored in the MSB of the mantissa, though this must be unpacked and cleared before reuse.

Operations are either of the form of A := A [operator] B ; A := [operator] A or string conversion two or from A. 

All angles are in *radians*. 

B is likely to be changed on exit. 

A will be changed when being converted to a string 

Strings are ASCIIZ format.

On exit, the carry flag is set on error.

All calls are done via the **FloatDo** macro e,g, "FloatDo Subtract"

|        Function        | Description                                                  |
| :--------------------: | ------------------------------------------------------------ |
|          Add           | Adds B to A                                                  |
|        Subtract        | Subtracts B from A                                           |
|        Multiply        | Multiplies A by B                                            |
|         Divide         | Divides A by B ; error on zero divide                        |
|       IntDivide        | Divides A by B as integers ; error on zero divide            |
|       Fractional       | Take the fraction part of A                                  |
|        Integer         | Take the integer part of A                                   |
|     FloatToString      | Convert A to a string representation, which is stored at floatBufferString |
| IntegerToDecimalString | Convert integer A to a string representation, which is stored at floatBufferString |
|    IntegerToString     | Convert integer A to a string representation in base Y, which is stored at floatBufferString |
|        Scale10         | Divide A by 10^y                                             |
|    StringToInteger     | Converts the string at (floatZ0) to an integer in A,error on cannot process |
|     StringToFloat      | Converts the string at (floatZ0) to an float in A,error on cannot process |
|       LogarithmE       | Calculate Logarithm base e of A, may return error            |
|        Exponent        | Calculate natural exponent of A, may return error            |
|       SquareRoot       | Calculate square root of A, may return error                 |
|          Sine          | Calculate sine of A                                          |
|         Cosine         | Calculate cosine of A                                        |
|        Tangent         | Calculate tangent of A                                       |
|       ArcTangent       | Calculate arctangent of A, may return error                  |



------

*Paul Robson*

*Version 1.0*

*22nd March 2025*